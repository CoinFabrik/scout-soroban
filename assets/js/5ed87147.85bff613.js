"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[2897],{9613:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>v});var n=r(9496);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(r),m=i,v=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return r?n.createElement(v,a(a({ref:t},u),{},{components:r})):n.createElement(v,a({ref:t},u))}));function v(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},5362:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=r(2564),i=(r(9496),r(9613));const o={},a="Iterators over indexing",l={unversionedId:"vulnerabilities/iterators-over-indexing",id:"vulnerabilities/iterators-over-indexing",title:"Iterators over indexing",description:"Description",source:"@site/docs/vulnerabilities/14-iterators-over-indexing.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/iterators-over-indexing",permalink:"/scout-soroban/docs/vulnerabilities/iterators-over-indexing",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/vulnerabilities/14-iterators-over-indexing.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Soroban version",permalink:"/scout-soroban/docs/vulnerabilities/soroban-version"},next:{title:"Detectors",permalink:"/scout-soroban/docs/detectors/"}},s={},c=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Remediation",id:"remediation",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...r}=e;return(0,i.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"iterators-over-indexing"},"Iterators over indexing"),(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,i.kt)("inlineCode",{parentName:"li"},"Best practices")),(0,i.kt)("li",{parentName:"ul"},"Vulnerability Severity: ",(0,i.kt)("inlineCode",{parentName:"li"},"Enhacement")),(0,i.kt)("li",{parentName:"ul"},"Detectors: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/iterators-over-indexing"},(0,i.kt)("inlineCode",{parentName:"a"},"iterators-over-indexing"))),(0,i.kt)("li",{parentName:"ul"},"Test Cases: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1"},(0,i.kt)("inlineCode",{parentName:"a"},"iterators-over-indexing-1")))),(0,i.kt)("p",null,"Iterating with hardcoded indexes is slower than using an iterator. Also, if the index is out of bounds, it will panic."),(0,i.kt)("p",null,"This could lead to potential integer overflow vulnerabilities, which would trigger a panic in debug builds or wrap in release mode, jeopardizing the integrity and security of the smart contract. Additionally, failing to verify the existence of data in storage before operations could result in unexpected errors or runtime failures, compromising the reliability of the contract execution."),(0,i.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,i.kt)("p",null,"Consider the following ",(0,i.kt)("inlineCode",{parentName:"p"},"Soroban")," contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"     pub fn sum(e: Env) -> Result<i32, Error> {\n        let mut ret = 0_i32;\n        let vec = e\n            .storage()\n            .instance()\n            .get::<DataKey, Vec<i32>>(&DataKey::Data)\n            .ok_or(Error::NoData)?;\n        for i in 0..4 {\n            ret = ret\n                .checked_add(vec.get(i).ok_or(Error::NoData)?)\n                .ok_or(Error::IntegerOverflow)?;\n        }\n        Ok(ret)\n    }\n")),(0,i.kt)("p",null,"The problem arises in the for loop. If ",(0,i.kt)("inlineCode",{parentName:"p"},"vec")," has less than 4 elements, the contract will panic."),(0,i.kt)("p",null,"The vulnerable code example can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1/vulnerable-example"},(0,i.kt)("inlineCode",{parentName:"a"},"here")),"."),(0,i.kt)("h2",{id:"remediation"},"Remediation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"     pub fn sum(e: Env) -> Result<i32, Error> {\n        let mut ret = 0_i32;\n        let vec = e\n            .storage()\n            .instance()\n            .get::<DataKey, Vec<i32>>(&DataKey::Data)\n            .ok_or(Error::NoData)?;\n        for i in vec {\n            ret = ret.checked_add(i).ok_or(Error::IntegerOverflow)?;\n        }\n        Ok(ret)\n    }\n")),(0,i.kt)("p",null,"Instead of using a fixed loop, iterate through the vector itself using ",(0,i.kt)("inlineCode",{parentName:"p"},"for i in vec"),". This ensures the loop iterates only for valid elements present in the vector."),(0,i.kt)("p",null,"The remediated code example can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/iterators-over-indexing/iterators-over-indexing-1/remediated-example"},(0,i.kt)("inlineCode",{parentName:"a"},"here")),"."))}d.isMDXComponent=!0}}]);