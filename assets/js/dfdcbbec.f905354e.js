"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[9549],{9613:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var r=n(9496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),c=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},v=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=c(n),v=a,m=u["".concat(d,".").concat(v)]||u[v]||p[v]||o;return n?r.createElement(m,s(s({ref:t},l),{},{components:n})):r.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=v;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}v.displayName="MDXCreateElement"},9199:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(2564),a=(n(9496),n(9613));const o={},s="DoS unexpected revert with vector",i={unversionedId:"vulnerabilities/dos-unexpected-revert-with-vector",id:"vulnerabilities/dos-unexpected-revert-with-vector",title:"DoS unexpected revert with vector",description:"Description",source:"@site/docs/vulnerabilities/17-dos-unexpected-revert-with-vector.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/dos-unexpected-revert-with-vector",permalink:"/scout-soroban/docs/vulnerabilities/dos-unexpected-revert-with-vector",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/vulnerabilities/17-dos-unexpected-revert-with-vector.md",tags:[],version:"current",sidebarPosition:17,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Unprotected mapping operation",permalink:"/scout-soroban/docs/vulnerabilities/unprotected-mapping-operation"},next:{title:"Unrestricted Transfer From",permalink:"/scout-soroban/docs/vulnerabilities/unrestricted-transfer-from"}},d={},c=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Remediation",id:"remediation",level:2},{value:"References",id:"references",level:2}],l={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"dos-unexpected-revert-with-vector"},"DoS unexpected revert with vector"),(0,a.kt)("h2",{id:"description"},"Description"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,a.kt)("inlineCode",{parentName:"li"},"DoS")),(0,a.kt)("li",{parentName:"ul"},"Severity: ",(0,a.kt)("inlineCode",{parentName:"li"},"Medium")),(0,a.kt)("li",{parentName:"ul"},"Detectors: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/dos-unexpected-revert-with-vector"},(0,a.kt)("inlineCode",{parentName:"a"},"dos-unexpected-revert-with-vector"))),(0,a.kt)("li",{parentName:"ul"},"Test Cases: ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1"},(0,a.kt)("inlineCode",{parentName:"a"},"dos-unexpected-revert-with-vector-1")),", ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-2"},(0,a.kt)("inlineCode",{parentName:"a"},"dos-unexpected-revert-with-vector-2")))),(0,a.kt)("p",null,"This vulnerability of DoS through unexpected revert arises when a smart\ncontract does not handle storage size errors correctly, and a user can add an\nexcessive number of entries, leading to an unexpected revert of transactions\nby other users and a Denial of Service. This vulnerability can be exploited by\nan attacker to perform a DoS attack on the network and can result in lost\nfunds, poor user experience, and even harm the network's overall security."),(0,a.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,a.kt)("p",null,"The vulnerable smart contract we developed for his example allows users to\nvote for one of different candidates.\nThe smart contract contains a struct named ",(0,a.kt)("inlineCode",{parentName:"p"},"UnexpectedRevert")," that stores the\ntotal number of votes, a list of candidates, their votes, and whether an\naccount has voted. It also stores information about the most voted candidate\nand when the vote will end."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#![no_std]\n\nuse soroban_sdk::{\n    contract, contracterror, contractimpl, contracttype, symbol_short, Address, Env, Map, String,\n    Symbol, Vec,\n};\n\n#[contracterror]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n#[repr(u32)]\npub enum URError {\n    // Unexpected Revert Error\n    AccountAlreadyVoted = 1,\n    CandidateAlreadyAdded = 2,\n    CandidateDoesntExist = 3,\n    Overflow = 4,\n    TimestampBeforeCurrentBlock = 5,\n    VoteEnded = 6,\n}\n\n#[derive(Debug, Clone, PartialEq)]\n#[contracttype]\npub struct State {\n    total_votes: u64,\n    candidates: Vec<Address>,\n    votes: Map<Address, u64>,\n    already_voted: Map<Address, bool>,\n    most_voted_candidate: Address,\n    candidate_votes: u64,\n    vote_timestamp_end: u64,\n}\n\nconst STATE: Symbol = symbol_short!("STATE");\n\n#[contract]\npub struct UnexpectedRevert;\n\n#[contractimpl]\nimpl UnexpectedRevert {\n    pub fn init(env: Env, end_timestamp: u64) -> Result<State, URError> {\n        if end_timestamp <= env.ledger().timestamp() {\n            return Err(URError::TimestampBeforeCurrentBlock);\n        }\n\n        let zero_string: String = String::from_str(&env, "00000000000000000000000000000000");\n        let zero_addr = Address::from_string(&zero_string); //CHECK\n        let state = State {\n            total_votes: 0,\n            most_voted_candidate: zero_addr,\n            candidate_votes: 0,\n            candidates: Vec::new(&env),\n            already_voted: Map::new(&env),\n            votes: Map::new(&env),\n            vote_timestamp_end: end_timestamp,\n        };\n\n        env.storage().instance().set(&STATE, &state);\n        Ok(state)\n    }\n\n    pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n        let mut state = Self::get_state(env.clone());\n        if Self::vote_ended(env.clone()) {\n            return Err(URError::VoteEnded);\n        }\n        if state.already_voted.contains_key(caller.clone()) {\n            Err(URError::AccountAlreadyVoted)\n        } else {\n            state.candidates.push_back(candidate.clone());\n            state.votes.set(candidate, 0);\n            Ok(())\n        }\n    }\n\n    pub fn get_votes_for_a_candidate(env: Env, candidate: Address) -> Result<u64, URError> {\n        let state = Self::get_state(env.clone());\n        state\n            .votes\n            .get(candidate)\n            .ok_or(URError::CandidateDoesntExist)\n    }\n\n    pub fn most_voted_candidate_votes(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.candidate_votes\n    }\n\n    pub fn most_voted_candidate(env: Env) -> Address {\n        let state = Self::get_state(env);\n        state.most_voted_candidate\n    }\n\n    pub fn get_total_votes(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.total_votes\n    }\n\n    pub fn get_total_candidates(env: Env) -> u64 {\n        let state = Self::get_state(env);\n        state.candidates.len() as u64\n    }\n\n    pub fn get_candidate(env: Env, index: u32) -> Result<Address, URError> {\n        let state = Self::get_state(env);\n        if index < state.candidates.len() {\n            Ok(state.candidates.get(index).unwrap())\n        } else {\n            Err(URError::CandidateDoesntExist)\n        }\n    }\n\n    pub fn account_has_voted(env: Env, account: Address) -> bool {\n        let state = Self::get_state(env);\n        state.already_voted.get(account).unwrap_or(false)\n    }\n\n    pub fn vote(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n        caller.require_auth();\n        let mut state = Self::get_state(env.clone());\n        if Self::vote_ended(env.clone()) {\n            return Err(URError::VoteEnded);\n        }\n\n        if state.already_voted.contains_key(caller.clone()) {\n            Err(URError::AccountAlreadyVoted)\n        } else {\n            state.already_voted.set(caller, true);\n            let votes = state\n                .votes\n                .get(candidate.clone())\n                .ok_or(URError::CandidateDoesntExist)?\n                .checked_add(1)\n                .ok_or(URError::Overflow)?;\n            state.votes.set(candidate.clone(), votes);\n            state.total_votes.checked_add(1).ok_or(URError::Overflow)?;\n            if state.candidate_votes < votes {\n                state.candidate_votes = votes;\n                state.most_voted_candidate = candidate;\n            }\n            Ok(())\n        }\n    }\n\n    pub fn vote_ended(env: Env) -> bool {\n        let state = Self::get_state(env.clone());\n        state.vote_timestamp_end <= env.ledger().timestamp()\n    }\n\n    pub fn get_state(env: Env) -> State {\n        env.storage().instance().get(&STATE).unwrap()\n    }\n}\n')),(0,a.kt)("p",null,"The smart contract has several functions that allow adding a candidate, getting\nvotes for a specific candidate, getting the account ID of the most voted\ncandidate, getting the total votes, getting the total number of candidates,\ngetting a candidate by index, checking if an account has voted, and voting for\na candidate."),(0,a.kt)("p",null,"In this case, we see that a vector is being used to store the array of candidates for an election.\nNotice how the candidates array push operation has no access control or proper storage management in the function ",(0,a.kt)("inlineCode",{parentName:"p"},"add_candidate()"),", which can cause a revert if the array is full."),(0,a.kt)("p",null,"The vulnerable code example can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/blob/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1/vulnerable-example/src/lib.rs"},"here"),"."),(0,a.kt)("h2",{id:"remediation"},"Remediation"),(0,a.kt)("p",null,"This issue can be addressed in different ways. "),(0,a.kt)("p",null,"On the one hand, if the amount of candidates is going to be limited, and only authorized users are going to add new candidates, then enforcing this authorization would be a sufficient fix to prevent attackers from filling the array and producing a denial of service attack."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n    let mut state = Self::get_state(env.clone());\n     // Require authorization from an admin set at contract initalization.\n    state.admin.require_auth(); \n    if Self::vote_ended(env.clone()) {\n        return Err(URError::VoteEnded);\n    }\n    if state.already_voted.contains_key(caller.clone()) {\n        return Err(URError::AccountAlreadyVoted); \n    } else {\n        state.candidates.push_back(candidate.clone());\n        state.votes.set(candidate, 0);\n        Ok(())\n    }\n}\n")),(0,a.kt)("p",null,"This remediated code example can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/blob/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-1/remediated-example/src/lib.rs"},"here"),"."),(0,a.kt)("p",null,"Alternatively, if any user should be authorized to add new candidates, a different data structure should be used, one without the limitations of a vector. For example, a dictionary can be implemented in Soroban by defining a struct for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Candidate"),", accessible through a ",(0,a.kt)("inlineCode",{parentName:"p"},"DataKey")," enum like the one we have here. This data structure does not have the storage limitations of vectors, and using it to handle new candidates would prevent the issue."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"}," pub fn add_candidate(env: Env, candidate: Address, caller: Address) -> Result<(), URError> {\n      caller.require_auth();\n      let mut state = Self::get_state(env.clone());\n      if Self::vote_ended(env.clone()) {\n          return Err(URError::VoteEnded);\n      }\n      if Self::account_has_voted(env.clone(), caller.clone()) {\n          return Err(URError::AccountAlreadyVoted); \n      } else {\n          // Replace the Vector with a mapping like structure made with a DataKey enum.\n          env.storage().instance().set(&DataKey::Candidate(candidate.clone()), &Candidate{votes: 0});\n          state.total_candidates += 1; \n          env.storage().instance().set(&DataKey::State, &state);\n          Ok(())\n      }\n}\n")),(0,a.kt)("p",null,"This remediated code example can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/blob/main/test-cases/dos-unexpected-revert-with-vector/dos-unexpected-revert-with-vector-2/remediated-example/src/lib.rs"},"here"),"."),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://swcregistry.io/docs/SWC-113"},"SWC-113")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert"},"https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/src/levels/King.sol"},"Ethernaut: King"))))}p.isMDXComponent=!0}}]);