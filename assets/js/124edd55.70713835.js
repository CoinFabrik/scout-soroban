"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[4205],{9613:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(9496);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),h=i,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||r;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8210:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(2564),i=(a(9496),a(9613));const r={sidebar_position:2},o="Vulnerabilities",s={unversionedId:"vulnerabilities/README",id:"vulnerabilities/README",title:"Vulnerabilities",description:"This section lists relevant security-related issues typically introduced during the development of smart contracts. The list, though non-exhaustive, features highly relevant items. Each issue is assigned a severity label based on the taxonomy presented below.",source:"@site/docs/vulnerabilities/README.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/",permalink:"/scout-soroban/docs/vulnerabilities/",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/vulnerabilities/README.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Getting Started",permalink:"/scout-soroban/docs/intro"},next:{title:"Divide before multiply",permalink:"/scout-soroban/docs/vulnerabilities/divide-before-multiply"}},l={},c=[{value:"Vulnerability Severity",id:"vulnerability-severity",level:2},{value:"Vulnerability Categories",id:"vulnerability-categories",level:2},{value:"Vulnerability Classes",id:"vulnerability-classes",level:2},{value:"Divide before multiply",id:"divide-before-multiply",level:3},{value:"Unsafe unrwap",id:"unsafe-unrwap",level:3},{value:"Unsafe expect",id:"unsafe-expect",level:3},{value:"Integer overflow or underflow",id:"integer-overflow-or-underflow",level:3},{value:"Insufficiently random values",id:"insufficiently-random-values",level:3},{value:"Unprotected update of current contract wasm",id:"unprotected-update-of-current-contract-wasm",level:3},{value:"Avoid core::mem::forget",id:"avoid-corememforget",level:3},{value:"Set contract storage",id:"set-contract-storage",level:3},{value:"Avoid panic error",id:"avoid-panic-error",level:3},{value:"Avoid unsafe block",id:"avoid-unsafe-block",level:3},{value:"DoS unbounded operation",id:"dos-unbounded-operation",level:3},{value:"Soroban version",id:"soroban-version",level:3},{value:"Unused return enum",id:"unused-return-enum",level:3},{value:"Iterators-over-indexing",id:"iterators-over-indexing",level:3},{value:"Assert violation",id:"assert-violation",level:3},{value:"Unprotected mapping operation",id:"unprotected-mapping-operation",level:3},{value:"Unrestricted transfer from",id:"unrestricted-transfer-from",level:3},{value:"DoS unexpected revert with vector",id:"dos-unexpected-revert-with-vector",level:3},{value:"Unsafe map get",id:"unsafe-map-get",level:3},{value:"Zero or test address",id:"zero-or-test-address",level:3},{value:"Incorrect Exponentiation",id:"incorrect-exponentiation",level:3}],u={toc:c},d="wrapper";function p(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"vulnerabilities"},"Vulnerabilities"),(0,i.kt)("p",null,"This section lists relevant security-related issues typically introduced during the development of smart contracts. The list, though non-exhaustive, features highly relevant items. Each issue is assigned a severity label based on the taxonomy presented below."),(0,i.kt)("h2",{id:"vulnerability-severity"},"Vulnerability Severity"),(0,i.kt)("p",null,"This severity classification, although arbitrary, has been used in hundreds\nof security audits and helps to understand the vulnerabilities we introduce\nand measure the utility of this proof of concept."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Critical"),": These issues seriously compromise the system and must be addressed immediately."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Medium"),": These are potentially exploitable issues which might represent\na security risk in the near future. We suggest fixing them as soon as possible."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Minor"),": These issues represent problems that are relatively small or difficult to exploit, but might be exploited in combination with other issues. These kinds of issues do not block deployments in production environments. They should be taken into account and fixed when possible."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Enhancement"),": This class relates to issues stemming from deviations from best practices or stylistic conventions, which could escalate into higher-priority issues due to other changes. For instance, these issues may lead to development errors in future updates.")),(0,i.kt)("h2",{id:"vulnerability-categories"},"Vulnerability Categories"),(0,i.kt)("p",null,'We follow with a taxonomy of Vulnerabilities. Many "top vulnerability" lists\ncan be found covering Ethereum/Solidity smart contracts. This list below is\nused by the Coinfabrik Audit Team, when source code (security) audits in\nEthereum/Solidity, Stacks/Clarity, Algorand/PyTEAL /TEAL, Solana/RUST, etc.\nThe team discusses the creation of the list in this\n',(0,i.kt)("a",{parentName:"p",href:"https://blog.coinfabrik.com/analysis-categories/"},"blogpost"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Category"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Arithmetic"),(0,i.kt)("td",{parentName:"tr",align:null},"Proper usage of arithmetic and number representation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Assembly Usage"),(0,i.kt)("td",{parentName:"tr",align:null},"Detailed analysis of implementations using assembly.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Authorization"),(0,i.kt)("td",{parentName:"tr",align:null},"Vulnerabilities related to insufficient access control or incorrect authorization implementation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Best practices"),(0,i.kt)("td",{parentName:"tr",align:null},"Conventions and best practices for improved code quality and vulnerability prevention.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Block attributes"),(0,i.kt)("td",{parentName:"tr",align:null},"Appropriate usage of block attributes, especially when used as a source of randomness.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Centralization"),(0,i.kt)("td",{parentName:"tr",align:null},"Analysis of centralization and single points of failure.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Denial of Service"),(0,i.kt)("td",{parentName:"tr",align:null},"Denial of service. attacks.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Gas Usage"),(0,i.kt)("td",{parentName:"tr",align:null},"Performance issues, enhancements and vulnerabilities related to use of gas.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Known Bugs"),(0,i.kt)("td",{parentName:"tr",align:null},"Known issues that remain unresolved.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MEV"),(0,i.kt)("td",{parentName:"tr",align:null},"Patterns that could lead to the exploitation of Maximal Extractable Value.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Privacy"),(0,i.kt)("td",{parentName:"tr",align:null},"Patterns revealing sensible user or state data.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Reentrancy"),(0,i.kt)("td",{parentName:"tr",align:null},"Consistency of contract state under recursive calls.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Unexpected transfers"),(0,i.kt)("td",{parentName:"tr",align:null},"Contract behavior under unexpected or forced transfers of tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Upgradability"),(0,i.kt)("td",{parentName:"tr",align:null},"Proxy patterns and upgradable smart contracts.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Validations and error handling"),(0,i.kt)("td",{parentName:"tr",align:null},"Handling of errors, exceptions and parameters.")))),(0,i.kt)("p",null,"We used the above Vulnerability Categories, along with common examples of vulnerabilities detected within each category in other blockchains, as a guideline for finding and developing vulnerable examples of Stellar Soroban smart contracts."),(0,i.kt)("h2",{id:"vulnerability-classes"},"Vulnerability Classes"),(0,i.kt)("p",null,"As a result of our research, we have so far identified 4 types of vulnerabilities."),(0,i.kt)("p",null,"What follows is a description of each vulnerability in the context of Stellar Soroban smart contracts. In each case, we have produced at least one ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases"},"test-case")," smart contract that exposes one of these vulnerabilities."),(0,i.kt)("p",null,"Check our\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases"},"test-cases"),"\nfor code examples of these vulnerabilities and their respective remediations."),(0,i.kt)("h3",{id:"divide-before-multiply"},"Divide before multiply"),(0,i.kt)("p",null,"This vulnerability class relates to the order of operations in Rust, specifically in integer arithmetic. Performing a division operation before a multiplication can lead to a loss of precision. This issue becomes significant in programs like smart contracts where numerical precision is crucial."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Arithmetic")," category\nand has a Medium Severity."),(0,i.kt)("h3",{id:"unsafe-unrwap"},"Unsafe unrwap"),(0,i.kt)("p",null,"This vulnerability class pertains to the inappropriate usage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrap")," method in Rust, which is commonly employed for error handling. The ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrap")," method retrieves the inner value of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Result"),", but if an error or ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," occurs, it triggers a panic and crashes the program."),(0,i.kt)("p",null,"This vulnerability again falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category and has a Medium severity."),(0,i.kt)("p",null,"In our example, we consider an contract that utilizes the ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrap")," method to retrieve the balance of an account from a mapping. If there is no entry for the specified account, the contract will panic and abruptly halt execution, opening avenues for malicious exploitation."),(0,i.kt)("h3",{id:"unsafe-expect"},"Unsafe expect"),(0,i.kt)("p",null,"In Rust, the ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," method is commonly used for error handling. It retrieves the value from a ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and panics with a specified error message if an error occurs. However, using ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," can lead to unexpected program crashes."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category\nand has a Medium severity."),(0,i.kt)("p",null,"In our example, we see an exploit scenario involving a contract using the ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," method in a function that retrieves the balance of an account. If there is no entry for the account, the contract panics and halts execution, enabling malicious exploitation."),(0,i.kt)("h3",{id:"integer-overflow-or-underflow"},"Integer overflow or underflow"),(0,i.kt)("p",null,"This type of vulnerability occurs when an arithmetic operation attempts to\ncreate a numeric value that is outside the valid range in substrate, e.g,\na ",(0,i.kt)("inlineCode",{parentName:"p"},"u8")," unsigned integer can be at most ",(0,i.kt)("em",{parentName:"p"},"M:=2^8-1=255"),", hence the sum ",(0,i.kt)("inlineCode",{parentName:"p"},"M+1"),"\nproduces an overflow."),(0,i.kt)("p",null,"An overflow/underflow is typically caught and generates an error. When it\nis not caught, the operation will result in an inexact result which could\nlead to serious problems."),(0,i.kt)("p",null,"We classified this type of vulnerability under\nthe ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Arithmetic")," category and assigned it a\nCritical severity."),(0,i.kt)("p",null,"In the context of Soroban, we found that this vulnerability could only be\nrealized if ",(0,i.kt)("inlineCode",{parentName:"p"},"overflow-checks")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"[profile.release]")," section of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),".\nNotwithstanding, there are contexts where developers do turn off checks for\nvalid reasons and hence the reason for including this vulnerability in the\nlist."),(0,i.kt)("h3",{id:"insufficiently-random-values"},"Insufficiently random values"),(0,i.kt)("p",null,"Using block attributes like ledger ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp()")," and ledger ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence()")," for random number generation in Soroban smart contracts is not recommended due to the predictability of these values. Block attributes are publicly visible and deterministic, making it easy for malicious actors to anticipate their values and manipulate outcomes to their advantage. Furthermore, validators could potentially influence these attributes, further exacerbating the risk of manipulation. For truly random number generation, it's important to use a source that is both unpredictable and external to the blockchain environment, reducing the potential for malicious exploitation."),(0,i.kt)("p",null,"This vulnerability again falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Block attributes")," category\nand has a Critical severity."),(0,i.kt)("h3",{id:"unprotected-update-of-current-contract-wasm"},"Unprotected update of current contract wasm"),(0,i.kt)("p",null,"If users are allowed to call ",(0,i.kt)("inlineCode",{parentName:"p"},"update_current_contract_wasm()"),", they can intentionally modify the contract behaviour, leading to the loss of all associated data/tokens and functionalities given by this contract or by others that depend on it. To prevent this, the function should be restricted to administrators or authorized users only."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Authorization")," category and has a Critical severity."),(0,i.kt)("h3",{id:"avoid-corememforget"},"Avoid core::mem::forget"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"core::mem::forget")," function is used to forget about a value without running its destructor. This could lead to memory leaks and logic errors."),(0,i.kt)("p",null,"We classified this issue, a deviation from best practices which could have\nsecurity implications, under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Best practices")," category and assigned it an Enhancement severity."),(0,i.kt)("h3",{id:"set-contract-storage"},"Set contract storage"),(0,i.kt)("p",null,"Smart contracts can store important information in memory which changes through the contract's lifecycle. Changes happen via user interaction with the smart contract. An ",(0,i.kt)("em",{parentName:"p"},"unauthorized")," set contract storage vulnerability happens when a smart contract call allows a user to set or modify contract memory when they were not supposed to be authorized."),(0,i.kt)("p",null,"Common practice is to have functions with the ability to change\nsecurity-relevant values in memory to be only accessible to specific roles,\ne.g, only an admin can call the function ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()")," which resets auction values.\nWhen this does not happen, arbitrary users may alter memory which may impose\ngreat damage to the smart contract users."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"Soroban"),", the method ",(0,i.kt)("inlineCode",{parentName:"p"},"env.storage()")," can be used\nto modify the contract storage under a given key. When a smart contract uses\nthis method, the contract needs to check if the caller should be able to\nalter this storage. If this does not happen, an arbitary caller may modify\nbalances and other relevant contract storage."),(0,i.kt)("p",null,"We classified this type of vulnerability under\nthe ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Authorization")," category and assigned it a\nCritical severity."),(0,i.kt)("h3",{id:"avoid-panic-error"},"Avoid panic error"),(0,i.kt)("p",null,"The use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"panic!")," macro to stop execution when a condition is not met is\nuseful for testing and prototyping but should be avoided in production code.\nUsing ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," as the return type for functions that can fail is the idiomatic\nway to handle errors in Rust."),(0,i.kt)("p",null,"We classified this issue, a deviation from best practices which could have\nsecurity implications, under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category and assigned it an Enhancement severity."),(0,i.kt)("h3",{id:"avoid-unsafe-block"},"Avoid unsafe block"),(0,i.kt)("p",null,"The use of ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks in Rust is generally discouraged due to the potential risks it poses to the safety and reliability of the code. Rust's primary appeal lies in its ability to provide memory safety guarantees, which are largely enforced through its ownership and type systems. When you enter an ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block, you're effectively bypassing these safety checks. This can lead to various issues, such as undefined behavior, memory leaks, or security vulnerabilities. These blocks require the programmer to manually ensure that memory is correctly managed and accessed, which is prone to human error and can be challenging even for experienced developers. Therefore, unsafe blocks should only be used when absolutely necessary and when the safety of the operations within can be assured."),(0,i.kt)("p",null,"We classified this issue, a deviation from best practices which could have\nsecurity implications, under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category and assigned it a Critical severity."),(0,i.kt)("h3",{id:"dos-unbounded-operation"},"DoS unbounded operation"),(0,i.kt)("p",null,"Each block in Soroban Stellar has an upper bound on the amount of gas\nthat can be spent, and thus the amount of computation that can be done. This\nis the Block Gas Limit. If the gas spent by a function call on a Soroban smart\ncontract exceeds this limit, the transaction will fail. Sometimes it is the\ncase that the contract logic allows a malicious user to modify conditions\nso that other users are forced to exhaust gas on standard function calls."),(0,i.kt)("p",null,"In order to prevent a single transaction from consuming all the gas in a block,\nunbounded operations must be avoided. This includes loops that do not have a\nbounded number of iterations, and recursive calls."),(0,i.kt)("p",null,"A denial of service vulnerability allows the exploiter to hamper the\navailability of a service rendered by the smart contract. In the context\nof Soroban smart contracts, it can be caused by the exhaustion of gas,\nstorage space, or other failures in the contract's logic."),(0,i.kt)("p",null,"We classified this type of vulnerability under\nthe ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Denial of Service")," category and assigned it a\nMedium severity."),(0,i.kt)("h3",{id:"soroban-version"},"Soroban version"),(0,i.kt)("p",null,"Using an old version of Soroban can be dangerous, as it may have bugs or security issues. Use the latest version available."),(0,i.kt)("p",null,"We classified this issue, a deviation from best practices which could have\nsecurity implications, under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Best practices")," category and assigned it an Enhancement severity."),(0,i.kt)("h3",{id:"unused-return-enum"},"Unused return enum"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Rust")," messages can return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," with a custom error type. This is\nuseful for the caller to know what went wrong when the message fails. The\ndefinition of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," type enum consists of two variants: Ok and Err. If\nany of the variants is not used, the code could be simplified or it could imply\na bug."),(0,i.kt)("p",null,"We put this vulnerability under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling category")," with a Minor severity."),(0,i.kt)("h3",{id:"iterators-over-indexing"},"Iterators-over-indexing"),(0,i.kt)("p",null,"Accessing a vector by index is slower than using an iterator. Also, if the index is out of bounds, it will panic. "),(0,i.kt)("p",null,"This could lead to potential integer overflow vulnerabilities, which would trigger a panic in debug builds or wrap in release mode, jeopardizing the integrity and security of the smart contract. Additionally, failing to verify the existence of data in storage before operations could result in unexpected errors or runtime failures, compromising the reliability of the contract execution."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Best practices")," category and has an Enhancement severity."),(0,i.kt)("h3",{id:"assert-violation"},"Assert violation"),(0,i.kt)("p",null,"The assert! macro is used in Rust to ensure that a certain condition holds true at a certain point in your code. The ",(0,i.kt)("inlineCode",{parentName:"p"},"assert!")," macro can cause the contract to panic. Therefore, the detector suggests replacing ",(0,i.kt)("inlineCode",{parentName:"p"},"assert!")," constructs with ",(0,i.kt)("inlineCode",{parentName:"p"},"Error")," enum structures."),(0,i.kt)("p",null,"This vulnerability falls under the category ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," and has an Enhancement severity."),(0,i.kt)("h3",{id:"unprotected-mapping-operation"},"Unprotected mapping operation"),(0,i.kt)("p",null,"Modifying mappings with an arbitrary key given by the user could lead to unintented modifications of critical data, modifying data belonging to other users, causing denial of service, unathorized access, and other potential issues."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling category")," and assigned it a Critical severity."),(0,i.kt)("h3",{id:"unrestricted-transfer-from"},"Unrestricted transfer from"),(0,i.kt)("p",null,"In a smart contract, allowing unrestricted ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer_from")," operations poses a significant vulnerability. When ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," arguments for that function is provided directly by the user, this might enable the withdrawal of funds from any actor with token approval on the contract. This could result in unauthorized transfers and loss of funds. To mitigate this vulnerability, instead of allowing an arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," address, the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," address should be restricted."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category\nand has a Critical severity."),(0,i.kt)("h3",{id:"dos-unexpected-revert-with-vector"},"DoS unexpected revert with vector"),(0,i.kt)("p",null,"Another type of Denial of Service attack is called unexpected revert. It occurs\nby preventing transactions by other users from being successfully executed,\nforcing the blockchain state to revert to its original state."),(0,i.kt)("p",null,"A Denial of Service through unexpected revert can\naccomplished by exploiting a smart contract that does not manage storage size\nerrors correctly. It can be prevented by using Mapping instead of Vec to avoid\nstorage limit problems."),(0,i.kt)("p",null,"This vulnerability again falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Denial of Service")," category\nand has a Medium severity."),(0,i.kt)("h3",{id:"unsafe-map-get"},"Unsafe map get"),(0,i.kt)("p",null,"The use of certain methods (",(0,i.kt)("inlineCode",{parentName:"p"},"get"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"get_unchecked"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"try_get_unchecked"),") on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," object in the Soroban environment without appropriate error handling can lead to potential runtime panics. This vulnerability stems from accessing the map's values with keys that may not exist, without using safer alternatives that check the existence of the key. Such practices can compromise the robustness of the smart contract by causing it to terminate unexpectedly, which may lead to denial of service or inconsistent state within the contract."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling category")," category and is assigned a Medium severity level."),(0,i.kt)("h3",{id:"zero-or-test-address"},"Zero or test address"),(0,i.kt)("p",null,"The assignment of the zero address to a variable in a smart contract represents a critical vulnerability because it can lead to loss of control over the contract. This stems from the fact that the zero address does not have an associated private key, which means it's impossible to claim ownership, rendering any contract assets or functions permanently inaccessible."),(0,i.kt)("p",null,"Assigning a test address can also have similar implications, including the loss of access or granting access to a malicious actor if its private keys are not handled with care."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Validations and error handling")," category\nand has a Medium severity."),(0,i.kt)("h3",{id:"incorrect-exponentiation"},"Incorrect Exponentiation"),(0,i.kt)("p",null,"It's common to use ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," for exponentiation. However in Rust, ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," is the XOR operator. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," operator is used, it could lead to unexpected behavior in the contract. It's recommended to use the method ",(0,i.kt)("inlineCode",{parentName:"p"},"pow()")," for exponentiation or ",(0,i.kt)("inlineCode",{parentName:"p"},".bitxor()")," for XOR operations."),(0,i.kt)("p",null,"This vulnerability falls under the ",(0,i.kt)("a",{parentName:"p",href:"#vulnerability-categories"},"Arithmetic")," category and has a Critical severity."))}p.isMDXComponent=!0}}]);