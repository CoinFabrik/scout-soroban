"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[19],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>b});var r=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),f=o,b=d["".concat(l,".").concat(f)]||d[f]||p[f]||a;return n?r.createElement(b,i(i({ref:t},c),{},{components:n})):r.createElement(b,i({ref:t},c))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var r=n(2564),o=(n(9496),n(9613));const a={},i="Avoid unsafe block",s={unversionedId:"detectors/avoid-unsafe-block",id:"detectors/avoid-unsafe-block",title:"Avoid unsafe block",description:"What it does",source:"@site/docs/detectors/10-avoid-unsafe-block.md",sourceDirName:"detectors",slug:"/detectors/avoid-unsafe-block",permalink:"/scout-soroban/docs/detectors/avoid-unsafe-block",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/detectors/10-avoid-unsafe-block.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Panic error",permalink:"/scout-soroban/docs/detectors/avoid-panic-error"},next:{title:"DoS unbounded operation",permalink:"/scout-soroban/docs/detectors/dos-unbounded-operation"}},l={},u=[{value:"What it does",id:"what-it-does",level:3},{value:"Why is this bad?",id:"why-is-this-bad",level:3},{value:"Example",id:"example",level:3},{value:"Implementation",id:"implementation",level:3}],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"avoid-unsafe-block"},"Avoid unsafe block"),(0,o.kt)("h3",{id:"what-it-does"},"What it does"),(0,o.kt)("p",null,"Checks for usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks."),(0,o.kt)("h3",{id:"why-is-this-bad"},"Why is this bad?"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks should not be used unless absolutely necessary. The use of unsafe blocks in Rust is discouraged because they bypass Rust's memory safety checks, potentially leading to issues like undefined behavior and security vulnerabilities."),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn unsafe_function(n: u64) -> u64 {\n   unsafe {\n       let mut i = n as f64;\n       let mut y = i.to_bits();\n       y = 0x5fe6ec85e7de30da - (y >> 1);\n       i = f64::from_bits(y);\n       i *= 1.5 - 0.5 * n as f64 * i * i;\n       i *= 1.5 - 0.5 * n as f64 * i * i;\n\n       let result_ptr: *mut f64 = &mut i;\n       let result = *result_ptr;\n\n       result.to_bits()\n    }\n}\n")),(0,o.kt)("p",null,"Use instead:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn unsafe_function(n: u64) -> u64 {\n       let mut i = n as f64;\n       let mut y = i.to_bits();\n       y = 0x5fe6ec85e7de30da - (y >> 1);\n       i = f64::from_bits(y);\n       i *= 1.5 - 0.5 * n as f64 * i * i;\n       i *= 1.5 - 0.5 * n as f64 * i * i;\n       result.to_bits()\n}\n")),(0,o.kt)("h3",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"The detector's implementation can be found at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/avoid-unsafe-block"},"this link"),"."))}p.isMDXComponent=!0}}]);