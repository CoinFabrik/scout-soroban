"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[7704],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),f=r,m=p["".concat(l,".").concat(f)]||p[f]||d[f]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1276:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(2564),r=(n(9496),n(9613));const i={},o="Avoid unsafe block",s={unversionedId:"vulnerabilities/avoid-unsafe-block",id:"vulnerabilities/avoid-unsafe-block",title:"Avoid unsafe block",description:"Description",source:"@site/docs/vulnerabilities/10-avoid-unsafe-block.md",sourceDirName:"vulnerabilities",slug:"/vulnerabilities/avoid-unsafe-block",permalink:"/scout-soroban/docs/vulnerabilities/avoid-unsafe-block",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/vulnerabilities/10-avoid-unsafe-block.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Set contract storage",permalink:"/scout-soroban/docs/vulnerabilities/set-contract-storage"},next:{title:"Soroban version",permalink:"/scout-soroban/docs/vulnerabilities/soroban-version"}},l={},c=[{value:"Description",id:"description",level:2},{value:"Exploit Scenario",id:"exploit-scenario",level:2},{value:"Remediation",id:"remediation",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"avoid-unsafe-block"},"Avoid unsafe block"),(0,r.kt)("h2",{id:"description"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vulnerability Category: ",(0,r.kt)("inlineCode",{parentName:"li"},"Validations and error handling")),(0,r.kt)("li",{parentName:"ul"},"Severity: ",(0,r.kt)("inlineCode",{parentName:"li"},"Critical")),(0,r.kt)("li",{parentName:"ul"},"Detectors: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/avoid-unsafe-block"},(0,r.kt)("inlineCode",{parentName:"a"},"avoid-unsafe-block"))),(0,r.kt)("li",{parentName:"ul"},"Test Cases: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1"},(0,r.kt)("inlineCode",{parentName:"a"},"avoid-unsafe-block-1")))),(0,r.kt)("p",null,"The use of unsafe blocks in Rust is generally discouraged due to the potential risks it poses to the safety and reliability of the code. Rust's primary appeal lies in its ability to provide memory safety guarantees, which are largely enforced through its ownership and type systems. When you enter an unsafe block, you're effectively bypassing these safety checks. This can lead to various issues, such as undefined behavior, memory leaks, or security vulnerabilities. These blocks require the programmer to manually ensure that memory is correctly managed and accessed, which is prone to human error and can be challenging even for experienced developers. Therefore, unsafe blocks should only be used when absolutely necessary and when the safety of the operations within can be assured."),(0,r.kt)("h2",{id:"exploit-scenario"},"Exploit Scenario"),(0,r.kt)("p",null,"In this example we can see that it creates a raw pointer named ",(0,r.kt)("inlineCode",{parentName:"p"},"result_ptr"),". Then ",(0,r.kt)("inlineCode",{parentName:"p"},"(*result_ptr).to_bits()")," dereferences the raw pointer. This directly accesses the memory location and calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"to_bits")," method on the value stored at that location."),(0,r.kt)("p",null,"Raw pointers bypass Rust's type safety system and memory management features. If something goes wrong with the calculations or the value of n, dereferencing the pointer could lead to a memory access violations or undefined behavior."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[contractimpl]\nimpl AvoidUnsafeBlock {\n    pub fn unsafe_function(n: u64) -> u64 {\n        unsafe {\n            let mut i = n as f64;\n            let mut y = i.to_bits();\n            y = 0x5fe6ec85e7de30da - (y >> 1);\n            i = f64::from_bits(y);\n            i *= 1.5 - 0.5 * n as f64 * i * i;\n            i *= 1.5 - 0.5 * n as f64 * i * i;\n\n            let result_ptr: *mut f64 = &mut i;\n\n            (*result_ptr).to_bits()\n        }\n    }\n}\n")),(0,r.kt)("p",null,"The vulnerable code example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1/vulnerable-example"},"here"),"."),(0,r.kt)("h2",{id:"remediation"},"Remediation"),(0,r.kt)("p",null,"By removing the raw pointer, the following version eliminates the vulnerability associated with dereferencing memory in an unsafe way. Rust's type safety checks ensure memory is accessed correctly, preventing the potential issues mentioned earlier. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[contractimpl]\nimpl AvoidUnsafeBlock {\n    pub fn unsafe_function(n: u64) -> u64 {\n        let mut i = n as f64;\n        let mut y = i.to_bits();\n        y = 0x5fe6ec85e7de30da - (y >> 1);\n        i = f64::from_bits(y);\n        i *= 1.5 - 0.5 * n as f64 * i * i;\n        i *= 1.5 - 0.5 * n as f64 * i * i;\n        i.to_bits()\n    }\n}\n")),(0,r.kt)("p",null,"The remediated code example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1/remediated-example"},"here"),"."))}d.isMDXComponent=!0}}]);