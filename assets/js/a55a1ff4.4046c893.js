"use strict";(self.webpackChunkscout=self.webpackChunkscout||[]).push([[19],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(2564),o=(n(9496),n(9613));const r={},i="Avoid unsafe block",s={unversionedId:"detectors/avoid-unsafe-block",id:"detectors/avoid-unsafe-block",title:"Avoid unsafe block",description:"Description",source:"@site/docs/detectors/10-avoid-unsafe-block.md",sourceDirName:"detectors",slug:"/detectors/avoid-unsafe-block",permalink:"/scout-soroban/docs/detectors/avoid-unsafe-block",draft:!1,editUrl:"https://github.com/CoinFabrik/scout-soroban/docs/detectors/10-avoid-unsafe-block.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Avoid panic error",permalink:"/scout-soroban/docs/detectors/avoid-panic-error"},next:{title:"DoS unbounded operation",permalink:"/scout-soroban/docs/detectors/dos-unbounded-operation"}},l={},c=[{value:"Description",id:"description",level:2},{value:"Why is this bad?",id:"why-is-this-bad",level:2},{value:"Issue example",id:"issue-example",level:2},{value:"Remediated example",id:"remediated-example",level:2},{value:"How is it detected?",id:"how-is-it-detected",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"avoid-unsafe-block"},"Avoid unsafe block"),(0,o.kt)("h2",{id:"description"},"Description"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Category: ",(0,o.kt)("inlineCode",{parentName:"li"},"Validations and error handling")),(0,o.kt)("li",{parentName:"ul"},"Severity: ",(0,o.kt)("inlineCode",{parentName:"li"},"Critical")),(0,o.kt)("li",{parentName:"ul"},"Detector: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/detectors/avoid-unsafe-block"},(0,o.kt)("inlineCode",{parentName:"a"},"avoid-unsafe-block"))),(0,o.kt)("li",{parentName:"ul"},"Test Cases: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1"},(0,o.kt)("inlineCode",{parentName:"a"},"avoid-unsafe-block-1"))," ")),(0,o.kt)("p",null,"The use of unsafe blocks in Rust is generally discouraged due to the potential risks it poses to the safety and reliability of the code. Rust's primary appeal lies in its ability to provide memory safety guarantees, which are largely enforced through its ownership and type systems. When you enter an unsafe block, you're effectively bypassing these safety checks. These blocks require the programmer to manually ensure that memory is correctly managed and accessed, which is prone to human error and can be challenging even for experienced developers. Therefore, unsafe blocks should only be used when absolutely necessary and when the safety of the operations within can be assured."),(0,o.kt)("h2",{id:"why-is-this-bad"},"Why is this bad?"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks should not be used unless absolutely necessary. The use of unsafe blocks in Rust is discouraged because they bypass Rust's memory safety checks, potentially leading to issues like undefined behavior and security vulnerabilities."),(0,o.kt)("h2",{id:"issue-example"},"Issue example"),(0,o.kt)("p",null,"Consider the following ",(0,o.kt)("inlineCode",{parentName:"p"},"Soroban")," contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[contractimpl]\nimpl AvoidUnsafeBlock {\n    pub fn unsafe_function(n: u64) -> u64 {\n        unsafe {\n            let mut i = n as f64;\n            let mut y = i.to_bits();\n            y = 0x5fe6ec85e7de30da - (y >> 1);\n            i = f64::from_bits(y);\n            i *= 1.5 - 0.5 * n as f64 * i * i;\n            i *= 1.5 - 0.5 * n as f64 * i * i;\n\n            let result_ptr: *mut f64 = &mut i;\n\n            (*result_ptr).to_bits()\n        }\n    }\n}\n")),(0,o.kt)("p",null,"In this example we can see that it creates a raw pointer named ",(0,o.kt)("inlineCode",{parentName:"p"},"result_ptr"),". Then ",(0,o.kt)("inlineCode",{parentName:"p"},"(*result_ptr).to_bits()")," dereferences the raw pointer. This directly accesses the memory location and calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"to_bits")," method on the value stored at that location."),(0,o.kt)("p",null,"Raw pointers bypass Rust's type safety system and memory management features. If something goes wrong with the calculations or the value of n, dereferencing the pointer could lead to a memory access violations or undefined behavior."),(0,o.kt)("p",null,"The code example can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1/vulnerable-example"},"here"),"."),(0,o.kt)("h2",{id:"remediated-example"},"Remediated example"),(0,o.kt)("p",null,"By removing the raw pointer, the following version eliminates the issue associated with dereferencing memory in an unsafe way. Rust's type safety checks ensure memory is accessed correctly, preventing the potential issues mentioned earlier."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"}," #[contractimpl]\nimpl AvoidUnsafeBlock {\n    pub fn unsafe_function(n: u64) -> u64 {\n        let mut i = n as f64;\n        let mut y = i.to_bits();\n        y = 0x5fe6ec85e7de30da - (y >> 1);\n        i = f64::from_bits(y);\n        i *= 1.5 - 0.5 * n as f64 * i * i;\n        i *= 1.5 - 0.5 * n as f64 * i * i;\n        i.to_bits()\n    }\n}   \n")),(0,o.kt)("p",null,"The remediated code example can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CoinFabrik/scout-soroban/tree/main/test-cases/avoid-unsafe-block/avoid-unsafe-block-1/remediated-example"},"here"),"."),(0,o.kt)("h2",{id:"how-is-it-detected"},"How is it detected?"),(0,o.kt)("p",null,"Checks for usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks."))}p.isMDXComponent=!0}}]);